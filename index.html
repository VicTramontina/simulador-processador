<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Processador Virtual</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: sans-serif;
        }

        body {
            margin: 0;
            padding: 0;
            background: #f5f5f5;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            margin-bottom: 20px;
        }

        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .controls input[type="file"] {
            padding: 5px;
            cursor: pointer;
        }

        .controls button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .controls button:hover {
            background: #45A049;
        }

        .panels {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }

        .panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .panel h2 {
            margin-top: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        table th, table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }

        pre {
            background: #eee;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .memory-view {
            max-height: 300px;
            overflow-y: auto;
        }

        .input-field {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
        }

        ol {
            padding-left: 20px;
            margin: 0;
        }

        li {
            padding: 2px 4px;
        }

        li.current {
            background-color: #ffeb3b;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Simulador de Processador Virtual</h1>
    <div class="controls">
        <input type="file" id="fileInput" accept=".txt,asm,md"/>
        <button id="stepBtn">Passo-a-passo</button>
        <button id="runBtn">Executar</button>
        <button id="resetBtn">Resetar</button>
    </div>
    <div class="panels">
        <div class="panel">
            <h2>Programa Carregado (Hex)</h2>
            <pre id="hexDisplay"></pre>
        </div>
        <div class="panel">
            <h2>Programa Carregado (Mnemonics)</h2>
            <pre id="mnemonicDisplay"></pre>
        </div>
        <div class="panel">
            <h2>Programa Linha a Linha</h2>
            <ol id="programList"></ol>
        </div>
        <div class="panel">
            <h2>Registradores</h2>
            <table>
                <thead>
                <tr>
                    <th>PC</th>
                    <th>SP</th>
                    <th>R0</th>
                    <th>R1</th>
                    <th>R2</th>
                    <th>R3</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td id="pc">0</td>
                    <td id="sp">0</td>
                    <td id="r0">0</td>
                    <td id="r1">0</td>
                    <td id="r2">0</td>
                    <td id="r3">0</td>
                </tr>
                </tbody>
            </table>
            <h3>Flags</h3>
            <table>
                <thead>
                <tr>
                    <th>Z</th>
                    <th>C</th>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td id="flagZ">0</td>
                    <td id="flagC">0</td>
                </tr>
                </tbody>
            </table>
        </div>
        <div class="panel">
            <h2>Memória</h2>
            <div class="memory-view">
                <table>
                    <thead>
                    <tr>
                        <th>Endereço</th>
                        <th>Valor</th>
                    </tr>
                    </thead>
                    <tbody id="memoryBody"></tbody>
                </table>
            </div>
        </div>
        <div class="panel">
            <h2>I/O</h2>
            <label for="inputInput">Entrada:</label>
            <input id="inputInput" class="input-field" type="text" placeholder="Texto de entrada"/>
            <h3>Saída:</h3>
            <pre id="output"></pre>
        </div>
    </div>
</div>
<script>
    const MNEMONIC_MAP = {
        'NADA': 0x00, 'CAR_IMD': 0x01, 'COPIA': 0x02, 'LE_MEM': 0x03, 'ES_MEM': 0x04,
        'SOMA': 0x05, 'SUBTRAI': 0x06, 'MULTIPLICA': 0x07, 'DIVIDE': 0x08, 'E_BIT': 0x09,
        'OU_BIT': 0x0A, 'NAO_BIT': 0x0B, 'SALTA': 0x0C, 'SALTA_Z': 0x0D, 'SALTA_NZ': 0x0E,
        'ENTRADA': 0x0F, 'SAIDA': 0x10, 'INC': 0x11, 'DEC': 0x12, 'MAIOR': 0x13,
        'ZERA': 0x14, 'LE_INDIRETO': 0x15, 'ES_INDIRETO': 0x16
    };
    const REGISTER_MAP = {'R0': 0, 'R1': 1, 'R2': 2, 'R3': 3};
    const INV_MAP = Object.entries(MNEMONIC_MAP).reduce((a, [k, v]) => (a[v] = k, a), {});
    let tokens = [], instructions = [], cpu = null;

    document.getElementById('fileInput').addEventListener('change', e => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = ev => {
            const text = ev.target.result;
            tokens = text
                .split(/\n/)
                .map(l => l.split(';')[0])
                .join(' ')
                .replace(/,/g, ' , ')
                .split(/\s+/)
                .filter(t => t);
            loadProgram();
        };
        reader.readAsText(file);
    });

    document.getElementById('inputInput').addEventListener('input', e => {
        if (cpu) cpu.input = e.target.value;
    });

    function loadProgram() {
        const labelMap = {};
        const operandCount = {
            0x00: 0,  // NADA
            0x01: 2,  // CAR_IMD
            0x02: 2,  // COPIA
            0x03: 2,  // LE_MEM
            0x04: 2,  // ES_MEM
            0x05: 2,  // SOMA
            0x06: 2,  // SUBTRAI
            0x07: 2,  // MULTIPLICA
            0x08: 2,  // DIVIDE
            0x09: 2,  // E_BIT
            0x0A: 2,  // OU_BIT
            0x0B: 1,  // NAO_BIT
            0x0C: 1,  // SALTA
            0x0D: 2,  // SALTA_Z
            0x0E: 2,  // SALTA_NZ
            0x0F: 1,  // ENTRADA
            0x10: 1,  // SAIDA
            0x11: 1,  // INC
            0x12: 1,  // DEC
            0x13: 3,  // MAIOR
            0x14: 1,  // ZERA
            0x15: 2,  // LE_INDIRETO
            0x16: 2   // ES_INDIRETO
        };
        let pcCount = 0;
        for (let i = 0; i < tokens.length; i++) {
            const tok = tokens[i].toUpperCase();
            if (tok.endsWith(':')) {
                labelMap[tok.slice(0, -1)] = pcCount;
            } else if (MNEMONIC_MAP[tok] != null) {
                const op = MNEMONIC_MAP[tok], cnt = operandCount[op] || 0;
                pcCount += 1 + cnt;
                i += cnt;
            }
        }
        const rom = [];
        for (let i = 0; i < tokens.length; i++) {
            const tok = tokens[i].toUpperCase();
            if (tok.endsWith(':')) continue;
            if (MNEMONIC_MAP[tok] != null) {
                const op = MNEMONIC_MAP[tok];
                rom.push(op);
                const cnt = operandCount[op] || 0;
                for (let j = 1; j <= cnt; j++) {
                    let opd = tokens[i + j].toUpperCase();
                    if (opd === ',') opd = '0';
                    if (REGISTER_MAP[opd] != null) rom.push(REGISTER_MAP[opd]);
                    else if (!isNaN(parseInt(opd))) rom.push(parseInt(opd) & 0xFF);
                    else if (labelMap[opd] != null) rom.push(labelMap[opd]);
                    else {
                        console.error('Operando inválido:', opd);
                        rom.push(0);
                    }
                }
                i += cnt;
            }
        }
        instructions = [];
        let idx = 0;
        while (idx < rom.length) {
            const op = rom[idx], cnt = operandCount[op] || 0;
            const bytes = rom.slice(idx, idx + 1 + cnt);
            const text = INV_MAP[op] + ' ' + bytes.slice(1).join(' ');
            instructions.push({startPC: idx, bytes, text});
            idx += 1 + cnt;
        }
        document.getElementById('hexDisplay').textContent = rom.map(b => b.toString(16).padStart(2, '0')).join(' ').toUpperCase();
        document.getElementById('mnemonicDisplay').textContent = tokens.join(' ');
        const list = document.getElementById('programList');
        list.innerHTML = '';
        instructions.forEach(instr => {
            const li = document.createElement('li');
            li.textContent = instr.text;
            li.dataset.startpc = instr.startPC;
            list.appendChild(li);
        });
        const inputText = document.getElementById('inputInput').value;
        cpu = new CPU(rom, inputText);
        updateUI();
    }

    class CPU {
        constructor(rom, input = '') {
            this.rom = rom;
            this.memory = new Uint8Array(256);
            this.registers = [0, 0, 0, 0];
            this.pc = 0;
            this.sp = 0;
            this.flags = {Z: 0, C: 0};
            this.input = input;
            this.inputPtr = 0;
            this.output = '';
            this.halted = false;
            this.lastPC = null;
        }

        reset() {
            this.memory.fill(0);
            this.registers = [0, 0, 0, 0];
            this.pc = 0;
            this.sp = 0;
            this.flags = {Z: 0, C: 0};
            this.inputPtr = 0;
            this.output = '';
            this.halted = false;
            this.lastPC = null;
        }

        fetch() {
            return this.rom[this.pc++];
        }

        step() {
            if (this.halted || this.pc < 0 || this.pc >= this.rom.length) return false;
            this.lastPC = this.pc;
            const op = this.fetch();
            switch (op) {
                case 0x00:
                    this.halted = true;
                    break;
                case 0x01: {
                    const r = this.fetch(), imm = this.fetch();
                    this.registers[r] = imm;
                }
                    break;
                case 0x02: {
                    const rd = this.fetch(), rs = this.fetch();
                    this.registers[rd] = this.registers[rs];
                }
                    break;
                case 0x03: {
                    const rd = this.fetch(), addr = this.fetch();
                    this.registers[rd] = this.memory[addr];
                }
                    break;
                case 0x04: {
                    const rs = this.fetch(), addr = this.fetch();
                    this.memory[addr] = this.registers[rs];
                }
                    break;
                case 0x05: {
                    const rd = this.fetch(), rs = this.fetch();
                    const res = this.registers[rd] + this.registers[rs];
                    this.flags.C = res > 255 ? 1 : 0;
                    this.registers[rd] = res & 0xFF;
                    this.flags.Z = this.registers[rd] === 0 ? 1 : 0;
                }
                    break;
                case 0x06: {
                    const rd = this.fetch(), rs = this.fetch();
                    const res = this.registers[rd] - this.registers[rs];
                    this.flags.C = res < 0 ? 1 : 0;
                    this.registers[rd] = res & 0xFF;
                    this.flags.Z = this.registers[rd] === 0 ? 1 : 0;
                }
                    break;
                case 0x07: {
                    const rd = this.fetch(), rs = this.fetch();
                    const res = this.registers[rd] * this.registers[rs];
                    this.flags.C = res > 255 ? 1 : 0;
                    this.registers[rd] = res & 0xFF;
                    this.flags.Z = this.registers[rd] === 0 ? 1 : 0;
                }
                    break;
                case 0x08: {
                    const rd = this.fetch(), rs = this.fetch();
                    this.registers[rd] = this.registers[rs] ? Math.floor(this.registers[rd] / this.registers[rs]) : 0;
                    this.flags.Z = this.registers[rd] === 0 ? 1 : 0;
                }
                    break;
                case 0x09: {
                    const rd = this.fetch(), rs = this.fetch();
                    this.registers[rd] &= this.registers[rs];
                    this.flags.Z = this.registers[rd] === 0 ? 1 : 0;
                }
                    break;
                case 0x0A: {
                    const rd = this.fetch(), rs = this.fetch();
                    this.registers[rd] |= this.registers[rs];
                    this.flags.Z = this.registers[rd] === 0 ? 1 : 0;
                }
                    break;
                case 0x0B: {
                    const rd = this.fetch();
                    this.registers[rd] = (~this.registers[rd] & 0xFF);
                    this.flags.Z = this.registers[rd] === 0 ? 1 : 0;
                }
                    break;
                case 0x0C:
                    this.pc = this.fetch();
                    break;
                case 0x0D: {
                    const cond = this.fetch(), addr = this.fetch();
                    if (this.flags.Z === 1) this.pc = addr;
                }
                    break;
                case 0x0E: {
                    const cond = this.fetch(), addr = this.fetch();
                    if (this.flags.Z === 0) this.pc = addr;
                }
                    break;
                case 0x0F: {
                    const rd = this.fetch();
                    this.registers[rd] = this.inputPtr < this.input.length ? this.input.charCodeAt(this.inputPtr++) & 0xFF : 0;
                    this.flags.Z = this.registers[rd] === 0 ? 1 : 0;
                }
                    break;
                case 0x10: {
                    const rs = this.fetch();
                    this.output += String.fromCharCode(this.registers[rs]);
                }
                    break;
                case 0x11: {
                    const rd = this.fetch();
                    const resInc = this.registers[rd] + 1;
                    this.flags.C = resInc > 255 ? 1 : 0;
                    this.registers[rd] = resInc & 0xFF;
                    this.flags.Z = this.registers[rd] === 0 ? 1 : 0;
                }
                    break;
                case 0x12: {
                    const rd = this.fetch();
                    const resDec = this.registers[rd] - 1;
                    this.flags.C = resDec < 0 ? 1 : 0;
                    this.registers[rd] = resDec & 0xFF;
                    this.flags.Z = this.registers[rd] === 0 ? 1 : 0;
                }
                    break;
                case 0x13: {
                    const rd = this.fetch(), r1 = this.fetch(), r2 = this.fetch();
                    this.registers[rd] = Math.max(this.registers[r1], this.registers[r2]);
                    this.flags.Z = this.registers[rd] === 0 ? 1 : 0;
                }
                    break;
                case 0x14: {
                    const rd = this.fetch();
                    this.registers[rd] = 0;
                    this.flags.Z = 1;
                }
                    break;
                case 0x15: {
                    const rd = this.fetch(), raddr = this.fetch();
                    this.registers[rd] = this.memory[this.registers[raddr]];
                }
                    break;
                case 0x16: {
                    const rs = this.fetch(), raddr = this.fetch();
                    this.memory[this.registers[raddr]] = this.registers[rs];
                }
                    break;
                default:
                    throw new Error('Opcode inválido: ' + op);
            }
            return !this.halted;
        }

        run(update) {
            while (this.step()) {
            }
            update();
        }
    }

    function updateUI() {
        if (!cpu) return;
        document.querySelectorAll('#programList li.current').forEach(li => li.classList.remove('current'));
        if (cpu.lastPC != null) {
            const li = document.querySelector(`#programList li[data-startpc="${cpu.lastPC}"]`);
            if (li) li.classList.add('current');
        }
        document.getElementById('pc').textContent = cpu.pc;
        document.getElementById('sp').textContent = cpu.sp;
        cpu.registers.forEach((v, i) => document.getElementById('r' + i).textContent = v);
        document.getElementById('flagZ').textContent = cpu.flags.Z;
        document.getElementById('flagC').textContent = cpu.flags.C;
        const mb = document.getElementById('memoryBody');
        mb.innerHTML = '';
        cpu.memory.forEach((v, i) => {
            if (v) mb.insertAdjacentHTML('beforeend', `<tr><td>${i}</td><td>${v}</td></tr>`);
        });
        document.getElementById('output').textContent = cpu.output;
    }

    document.getElementById('stepBtn').addEventListener('click', () => {
        if (cpu) {
            cpu.step();
            updateUI();
        }
    });
    document.getElementById('runBtn').addEventListener('click', () => {
        if (cpu) cpu.run(updateUI);
    });
    document.getElementById('resetBtn').addEventListener('click', () => {
        if (cpu) {
            cpu.reset();
            cpu.input = document.getElementById('inputInput').value;
            updateUI();
        }
    });
</script>
</body>
</html>