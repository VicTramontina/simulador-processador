<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simulador de Processador Virtual</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    textarea, input { font-family: monospace; }
    #controls, #io, #registers, #memory { margin-bottom: 20px; }
    table { border-collapse: collapse; }
    th, td { border: 1px solid #999; padding: 4px 8px; text-align: center; }
    #memoryTable td { width: 30px; }
    #output { display: inline-block; min-width: 200px; background: #f7f7f7; padding: 4px; }
  </style>
</head>
<body>
  <h1>Simulador de Processador Virtual</h1>
  <div id="controls">
    <textarea id="program" rows="8" cols="60" placeholder="Escreva o programa em mnemonicos e labels"></textarea><br>
    <button id="loadBtn">Carregar Programa</button>
    <button id="stepBtn" disabled>Passo a Passo</button>
    <button id="runBtn" disabled>Executar</button>
    <button id="resetBtn" disabled>Resetar</button>
  </div>
  <div id="io">
    <input id="inputField" type="text" placeholder="Entrada (texto)" />
    <button id="inputBtn">Enviar</button>
    <div>Saída: <span id="output"></span></div>
  </div>
  <div id="registers">
    <h2>Registradores</h2>
    <table>
      <tr><th>R0</th><th>R1</th><th>R2</th><th>R3</th><th>PC</th><th>SP</th><th>Z</th><th>C</th></tr>
      <tr><td id="r0">0</td><td id="r1">0</td><td id="r2">0</td><td id="r3">0</td><td id="pc">0</td><td id="sp">0</td><td id="flagZ">0</td><td id="flagC">0</td></tr>
    </table>
  </div>
  <div id="memory">
    <h2>Memória (256 bytes)</h2>
    <table id="memoryTable"></table>
  </div>
  <script>
    const OPCODES = {
      'NADA': 0x00,'CAR_IMD': 0x01,'COPIA': 0x02,'LE_MEM': 0x03,'ES_MEM': 0x04,
      'SOMA': 0x05,'SUBTRAI': 0x06,'MULTIPLICA': 0x07,'DIVIDE': 0x08,'E_BIT': 0x09,
      'OU_BIT': 0x0A,'NAO_BIT': 0x0B,'SALTA': 0x0C,'SALTA_Z': 0x0D,'SALTA_NZ': 0x0E,
      'ENTRADA': 0x0F,'SAIDA': 0x10,'INC': 0x11,'DEC': 0x12,'MAIOR': 0x13,'ZERA': 0x14,
      'LE_INDIRETO': 0x15,'ES_INDIRETO': 0x16
    };

    let memory = new Uint8Array(256);
    let regs = { r0:0, r1:0, r2:0, r3:0, pc:0, sp:255 };
    let flags = { Z:0, C:0 };
    let inputQueue = [];
    let running = false;

    const regsMap = ['r0','r1','r2','r3'];

    function initMemoryView() {
      const tbl = document.getElementById('memoryTable');
      tbl.innerHTML = '';
      for (let row = 0; row < 16; row++) {
        const tr = document.createElement('tr');
        for (let col = 0; col < 16; col++) {
          const addr = row*16 + col;
          const td = document.createElement('td');
          td.id = 'mem'+addr;
          td.textContent = '00';
          tr.appendChild(td);
        }
        tbl.appendChild(tr);
      }
    }

    function updateUI() {
      ['r0','r1','r2','r3','pc','sp'].forEach(id=>document.getElementById(id).textContent=regs[id]);
      document.getElementById('flagZ').textContent=flags.Z;
      document.getElementById('flagC').textContent=flags.C;
      for (let i=0;i<256;i++) document.getElementById('mem'+i).textContent=memory[i].toString(16).padStart(2,'0');
    }

    function parseProgram(text) {
      const lines = text.split(/\r?\n/);
      const labels = {};
      let addr = 0;
      // first pass: labels
      lines.forEach(line=>{
        const code = line.split(';')[0].trim();
        if (!code) return;
        const parts = code.split(/\s+/);
        if (parts[0].endsWith(':')) {
          labels[parts[0].slice(0,-1)] = addr;
        } else {
          addr += 1 + (parts.length-1);
        }
      });
      // second pass: assemble
      addr=0;
      lines.forEach(line=>{
        const code = line.split(';')[0].trim();
        if (!code) return;
        const parts = code.split(/\s+/);
        if (parts[0].endsWith(':')) return;
        const op = parts[0].toUpperCase();
        const opc = OPCODES[op];
        memory[addr++] = opc;
        parts.slice(1).forEach(tok=>{
          let val;
          if (tok.match(/^R[0-3]$/i)) val = parseInt(tok[1]);
          else if (tok.match(/^[0-9]+$/)) val = parseInt(tok);
          else if (labels[tok]!==undefined) val = labels[tok];
          else val = 0;
          memory[addr++] = val;
        });
      });
      regs.pc = 0; flags.Z=0; flags.C=0;
    }

    function step() {
      const op = memory[regs.pc++];
      let d, o1, o2;
      switch(op) {
        case 0x00: running=false; break;
        case 0x01: // CAR_IMD
          d = memory[regs.pc++]; regs[regsMap[d]] = memory[regs.pc++]; break;
        case 0x02: // COPIA
          d = memory[regs.pc++]; o1 = memory[regs.pc++]; regs[regsMap[d]] = regs[regsMap[o1]]; break;
        case 0x03: // LE_MEM
          d = memory[regs.pc++]; o1 = memory[regs.pc++]; regs[regsMap[d]] = memory[o1]; break;
        case 0x04: // ES_MEM
          o1 = memory[regs.pc++]; o2 = memory[regs.pc++]; memory[o2] = regs[regsMap[o1]]; break;
        case 0x05: // SOMA
          d = memory[regs.pc++]; o1 = memory[regs.pc++]; {
            const res = regs[regsMap[d]] + regs[regsMap[o1]];
            flags.C = res>255?1:0; regs[regsMap[d]] = res & 0xFF; flags.Z = regs[regsMap[d]]===0?1:0;
          } break;
        case 0x06: // SUBTRAI
          d = memory[regs.pc++]; o1 = memory[regs.pc++]; {
            const res = regs[regsMap[d]] - regs[regsMap[o1]];
            flags.C = res<0?1:0; regs[regsMap[d]] = res & 0xFF; flags.Z = regs[regsMap[d]]===0?1:0;
          } break;
        case 0x07: // MULTIPLICA
          d = memory[regs.pc++]; o1 = memory[regs.pc++]; {
            const res = regs[regsMap[d]] * regs[regsMap[o1]];
            flags.C = res>255?1:0; regs[regsMap[d]] = res & 0xFF; flags.Z = regs[regsMap[d]]===0?1:0;
          } break;
        case 0x08: // DIVIDE
          d = memory[regs.pc++]; o1 = memory[regs.pc++]; {
            const a=regs[regsMap[d]]; const b=regs[regsMap[o1]]||1;
            regs[regsMap[d]] = Math.floor(a/b); flags.Z = regs[regsMap[d]]===0?1:0; break;
          }
        case 0x09: // E_BIT
        case 0x0A: // OU_BIT
          d = memory[regs.pc++]; o1 = memory[regs.pc++]; {
            const a=regs[regsMap[d]]; const b=regs[regsMap[o1]];
            rsp = op===0x09 ? (a&b) : (a|b);
            regs[regsMap[d]] = rsp; flags.Z = rsp===0?1:0;
          } break;
        case 0x0B: // NAO_BIT
          d = memory[regs.pc++]; regs[regsMap[d]] = (~regs[regsMap[d]] & 0xFF); flags.Z = regs[regsMap[d]]===0?1:0; break;
        case 0x0C: // SALTA
          o1 = memory[regs.pc++]; regs.pc = o1; break;
        case 0x0D: // SALTA_Z
          o1 = memory[regs.pc++]; if (flags.Z) regs.pc = o1; break;
        case 0x0E: // SALTA_NZ
          o1 = memory[regs.pc++]; if (!flags.Z) regs.pc = o1; break;
        case 0x0F: // ENTRADA
          d = memory[regs.pc++]; regs[regsMap[d]] = inputQueue.length?inputQueue.shift().charCodeAt(0):0; break;
        case 0x10: // SAIDA
          o1 = memory[regs.pc++]; document.getElementById('output').textContent += String.fromCharCode(regs[regsMap[o1]]); break;
        case 0x11: // INC
          d = memory[regs.pc++]; regs[regsMap[d]] = (regs[regsMap[d]]+1)&0xFF; flags.Z = regs[regsMap[d]]===0?1:0; flags.C = regs[regsMap[d]]===0?1:0; break;
        case 0x12: // DEC
          d = memory[regs.pc++]; regs[regsMap[d]] = (regs[regsMap[d]]-1)&0xFF; flags.Z = regs[regsMap[d]]===0?1:0; flags.C = regs[regsMap[d]]===255?1:0; break;
        case 0x13: // MAIOR
          d = memory[regs.pc++]; let r1 = regs[regsMap[memory[regs.pc++]]]; let r2 = regs[regsMap[memory[regs.pc++]]]; const m = r1>r2?r1:r2; regs[regsMap[d]] = m; flags.Z = m===0?1:0; break;
        case 0x14: // ZERA
          d = memory[regs.pc++]; regs[regsMap[d]] = 0; flags.Z = 1; break;
        case 0x15: // LE_INDIRETO
          d = memory[regs.pc++]; o1 = memory[regs.pc++]; regs[regsMap[d]] = memory[regs[regsMap[o1]]]; break;
        case 0x16: // ES_INDIRETO
          o1 = memory[regs.pc++]; o2 = memory[regs.pc++]; memory[regs[regsMap[o2]]] = regs[regsMap[o1]]; break;
        default: running=false;
      }
      updateUI();
    }

    function runAll() { running=true; while(running) step(); }

    document.getElementById('loadBtn').onclick = () => {
      memory.fill(0); initMemoryView(); document.getElementById('output').textContent='';
      parseProgram(document.getElementById('program').value);
      updateUI();
      ['stepBtn','runBtn','resetBtn'].forEach(id=>document.getElementById(id).disabled=false);
    };
    document.getElementById('stepBtn').onclick = () => { step(); };
    document.getElementById('runBtn').onclick = () => { runAll(); };
    document.getElementById('resetBtn').onclick = () => { regs={r0:0,r1:0,r2:0,r3:0,pc:0,sp:255}; flags={Z:0,C:0}; memory.fill(0); document.getElementById('output').textContent=''; initMemoryView(); updateUI(); };
    document.getElementById('inputBtn').onclick = () => {
      const txt = document.getElementById('inputField').value;
      for (let ch of txt) inputQueue.push(ch);
      document.getElementById('inputField').value='';
    };

    // initialize on load
    initMemoryView(); updateUI();
  </script>
</body>
</html>
